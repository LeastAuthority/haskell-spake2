{-# LANGUAGE TypeFamilies #-}
{-# LANGUAGE NamedFieldPuns #-}
{-|
Module: Crypto.Spake2.Groups
Description: Interface and implementation for mathematical groups

Primary interface is the 'Group' typeclass.

=== Definitions

__NOTE__: This is jml's best understanding. It's likely to be wrong.

[@order@]: the number of elements in a group.

[@scalar@]: a number between 0 and \(p\) (that is, in \(\mathbb{Z}_{p}\)),
where \(p\) is the order of the group.
Normally written as a lower-case variable, e.g. \(x\) or \(pw\).

[@element@]: a member of the group, \(G\).
Normally written as an upper-case variable, e.g. \(X\) or \(M\).

[@addition@]: the binary operation on elements in the group \(G\).
Confusingly, literature often writes this using product notation.
More confusingly, warner and Sc00bz often use addition

[@scalar multiplication@]: adding a element to itself a scalar number of times.
Confusingly, this is often written as \(X^{n}\) where \(X\) is a element and \(n\) a scalar.
More confusingly, sometimes this is written with product notation, i.e. @x * Y@.

[@generator@]: element of a cyclic group, \(g\),
such that all members of the group can be generated by multiplying (group operation) \(g\) with itself.

-}
module Crypto.Spake2.Groups
  ( Group(..)
  , KeyPair(..)
  , IntegerAddition(..)
  , IntegerGroup
  , arbitraryElement
  , bytesToElement
  , expandArbitraryElementSeed
    -- * Utilities
  , expandData
  ) where

import Protolude hiding (group, length)

import Crypto.Error (CryptoFailable(..))
import Crypto.Hash.Algorithms (SHA256)
import qualified Crypto.KDF.HKDF as HKDF
import Crypto.Number.Basic (numBytes)
import Crypto.Number.ModArithmetic (expSafe)
import Crypto.Number.Serialize (i2osp, os2ip)
import Crypto.Random.Types (MonadRandom(..))
import Data.ByteArray (ByteArray, ByteArrayAccess(..))


-- | A mathematical group intended to be used with SPAKE2.
--
-- Notes:
--  * This is a much richer interface than one would expect from a group purely derived from abstract algebra
--  * jml thinks this is relevant to all Diffie-Hellman cryptography,
--    but too ignorant to say for sure
--  * Is this group automatically abelian? cyclic?
--    Must it have these properties?
class Group group where
  -- | An element of the group.
  type Element group :: *

  -- | A scalar for this group.
  -- Mathematically equivalent to an integer,
  -- but possibly stored differently for computational reasons.
  type Scalar group :: *

  -- | Group addition.
  --
  -- prop> \x y z -> elementAdd group (elementAdd group x y) z == elementAdd group x (elementAdd group y z)
  elementAdd :: group -> Element group -> Element group -> Element group

  -- | Inverse with respect to group addition.
  --
  -- prop> \x -> (elementAdd group x (elementNegate group x)) == groupIdentity
  -- prop> \x -> (elementNegate group (elementNegate group x)) == x
  elementNegate :: group -> Element group -> Element group

  -- | Subtract one element from another.
  --
  -- prop> \x y -> (elementSubtract group x y) == (elementAdd group x (elementNegate group y))
  elementSubtract :: group -> Element group -> Element group -> Element group
  elementSubtract group x y = elementAdd group x (elementNegate group y)

  -- | Identity of the group.
  --
  -- Note [Added for completeness]
  --
  -- prop> \x -> (elementAdd group x groupIdentity) == x
  -- prop> \x -> (elementAdd group groupIdentity x) == x
  groupIdentity :: group -> Element group

  -- | Multiply an element of the group with respect to a scalar.
  --
  -- This is equivalent to adding the element to itself N times, where N is a scalar.
  scalarMultiply :: group -> Scalar group -> Element group -> Element group

  -- | Get the scalar that corresponds to an integer.
  --
  -- Note [Added for completeness]
  --
  -- prop> \x -> scalarToInteger group (integerToScalar group x) == x
  integerToScalar :: group -> Integer -> Scalar group

  -- | Get the integer that corresponds to a scalar.
  --
  -- Note [Added for completeness]
  --
  -- prop> \x -> integerToScalar group (scalarToInteger group x) == x
  scalarToInteger :: group -> Scalar group -> Integer

  -- | Encode an element of the group into bytes.
  --
  -- Note [Byte encoding in Group]
  --
  -- prop> \x -> decodeElement group (encodeElement group x) == CryptoPassed x
  encodeElement :: ByteArray bytes => group -> Element group -> bytes

  -- | Decode an element into the group from some bytes.
  --
  -- Note [Byte encoding in Group]
  decodeElement :: ByteArray bytes => group -> bytes -> CryptoFailable (Element group)

  -- | Encode a scalar into bytes.
  -- | Generate a new random element of the group, with corresponding scalar.
  generateElement :: MonadRandom randomly => group -> randomly (KeyPair group)


-- | A group key pair composed of the private part (a scalar)
-- and a public part (associated group element).
data KeyPair group
  = KeyPair
  { keyPairPublic :: !(Element group)
  , keyPairPrivate :: !(Scalar group)
  }

{-
Note [Byte encoding in Group]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

jml is unsure whether it is a good idea to put encode/decode methods in the 'Group' typeclass.

Reasons for:

 * cryptonite does it with 'EllipticCurve'
 * warner does it with spake2.groups

Reasons against:

 * mathematical structure of groups has no connection to serialization
 * might want multiple encodings for same mathematical group

Including for now on the assumption that I'm ignorant.

TODO: Revisit decision to put byte encoding in Group after we've done a couple of implementations
-}

{-
Note [Added for completeness]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Several methods were added to 'Group' out of a desire for mathematical completeness
rather than necessity for implementing SPAKE2.

These include:

 * 'groupIdentity' -- because groups have identities (just like semigroups)
 * 'scalarToInteger' and 'integerToScalar' -- because scalars are mathematically integers
 * 'encodeScalar' -- because having an inverse of 'decodeScalar' makes it easier to test

-}

-- TODO: Would be nice to put all the group definitions into other modules and
-- leave this as being a pure interface module

newtype IntegerAddition = IntegerAddition { modulus :: Integer } deriving (Eq, Ord, Show)

instance Group IntegerAddition where
  type Element IntegerAddition = Integer
  type Scalar IntegerAddition = Integer

  elementAdd group x y = (x + y) `mod` modulus group
  elementNegate group x = negate x `mod` modulus group
  elementSubtract group x y = (x - y) `mod` modulus group
  groupIdentity _ = 0
  scalarMultiply group n x = (n * x) `mod` modulus group
  integerToScalar _ x = x
  scalarToInteger _ x = x
  encodeElement _ = i2osp
  decodeElement _ bytes = CryptoPassed (os2ip bytes)
  generateElement _ = notImplemented


data Error bytes
  = WrongSize bytes Int
  | WrongGroup bytes IntegerGroup
  | NotInField bytes Integer
  deriving (Eq, Ord, Show)

-- | Definitely about integers, but jml is not entirely sure why it's called a
-- group, since there's no inversion function, and since it also has scalar
-- multiplier.
data IntegerGroup
  = IntegerGroup
  { order :: Integer
  , fieldSize :: Integer
  , _generator :: Integer
  } deriving (Eq, Ord, Show)

type Bytes = Int  -- XXX: I guess this should be some sort of unsigned

elementSizeBytes :: IntegerGroup -> Bytes
elementSizeBytes group = numBytes (fieldSize group)

-- | An element of a group. It's up to you to remember which group this
-- element came from.
newtype ElementThing = Element Integer deriving (Eq, Ord, Show)


arbitraryElement :: ByteArrayAccess ikm => IntegerGroup -> ikm -> ElementThing
arbitraryElement group@IntegerGroup{order, fieldSize} seed =
  let processedSeed = expandArbitraryElementSeed seed (elementSizeBytes group) :: ByteString
      r = (order - 1) `div` fieldSize
      h = os2ip processedSeed `mod` order
  in Element (expSafe h r order)


bytesToElement :: ByteArrayAccess bytes => IntegerGroup -> bytes -> Either (Error bytes) ElementThing
bytesToElement group@IntegerGroup{order} bytes = do
  unless (length bytes == size) $ throwError (WrongSize bytes size)
  let i = os2ip bytes
  unless (0 < i && i < order) $ throwError (NotInField bytes order)
  let element = Element i
  unless (isMember group element) $ throwError (WrongGroup bytes group)
  pure element
  where
    size = elementSizeBytes group

isMember :: IntegerGroup -> ElementThing -> Bool
isMember IntegerGroup{order, fieldSize} (Element i) = expSafe i fieldSize order == 1

-- | Take an arbitrary sequence of bytes and expand it to be the given number
-- of bytes. Do this by extracting a pseudo-random key and expanding it using
-- HKDF.
expandData :: (ByteArrayAccess input, ByteArray output) => ByteString -> input -> Int -> output
expandData info input size =
  HKDF.expand prk info size
  where
    prk :: HKDF.PRK SHA256
    prk = HKDF.extract salt input

    -- XXX: I'm no crypto expert, but hard-coding an empty string as a salt
    -- seems kind of weird.
    salt :: ByteString
    salt = ""

expandArbitraryElementSeed :: (ByteArrayAccess ikm, ByteArray out) => ikm -> Int -> out
expandArbitraryElementSeed = expandData "SPAKE 2 arbitrary element"
