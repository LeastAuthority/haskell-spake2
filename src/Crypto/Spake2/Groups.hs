{-# LANGUAGE TypeFamilies #-}
{-# LANGUAGE NamedFieldPuns #-}
{-|
Module: Crypto.Spake2.Groups
Description: Interface and implementation for mathematical groups

Primary interface is the 'Group' typeclass.

=== Definitions

__NOTE__: This is jml's best understanding. It's likely to be wrong.

[@order@]: the number of elements in a group.

[@scalar@]: a number between 0 and \(p\) (that is, in \(\mathbb{Z}_{p}\)),
where \(p\) is the order of the group.
Normally written as a lower-case variable, e.g. \(x\) or \(pw\).

[@element@]: a member of the group, \(G\).
Normally written as an upper-case variable, e.g. \(X\) or \(M\).

[@addition@]: the binary operation on elements in the group \(G\).
Confusingly, literature often writes this using product notation.
More confusingly, warner and Sc00bz often use addition

[@scalar multiplication@]: adding a element to itself a scalar number of times.
Confusingly, this is often written as \(X^{n}\) where \(X\) is a element and \(n\) a scalar.
More confusingly, sometimes this is written with product notation, i.e. @x * Y@.

[@generator@]: element of a cyclic group, \(g\),
such that all members of the group can be generated by multiplying (group operation) \(g\) with itself.

-}
module Crypto.Spake2.Groups
  ( Group(..)
  , decodeScalar
  , elementSizeBytes
  , scalarSizeBytes
  , KeyPair(..)
  -- * Groups
  , IntegerAddition(..)
  , IntegerGroup(order, subgroupOrder)
  , makeIntegerGroup
  , i1024
  ) where

import Protolude hiding (group, length)

import Crypto.Error (CryptoFailable(..), CryptoError(..))
import Crypto.Number.Basic (numBits)
import Crypto.Number.Generate (generateMax)
import Crypto.Number.ModArithmetic (expSafe)
import Crypto.Random.Types (MonadRandom(..))
import Data.ByteArray (ByteArray, ByteArrayAccess(..))

import Crypto.Spake2.Util
  ( expandArbitraryElementSeed
  , bytesToNumber
  , unsafeNumberToBytes
  )


-- | A mathematical group intended to be used with SPAKE2.
--
-- Notes:
--  * This is a much richer interface than one would expect from a group purely derived from abstract algebra
--  * jml thinks this is relevant to all Diffie-Hellman cryptography,
--    but too ignorant to say for sure
--  * Is this group automatically abelian? cyclic?
--    Must it have these properties?
class Group group where
  -- | An element of the group.
  type Element group :: *

  -- | A scalar for this group.
  -- Mathematically equivalent to an integer,
  -- but possibly stored differently for computational reasons.
  type Scalar group :: *

  -- | Group addition.
  --
  -- prop> \x y z -> elementAdd group (elementAdd group x y) z == elementAdd group x (elementAdd group y z)
  elementAdd :: group -> Element group -> Element group -> Element group

  -- | Inverse with respect to group addition.
  --
  -- prop> \x -> (elementAdd group x (elementNegate group x)) == groupIdentity
  -- prop> \x -> (elementNegate group (elementNegate group x)) == x
  elementNegate :: group -> Element group -> Element group

  -- | Subtract one element from another.
  --
  -- prop> \x y -> (elementSubtract group x y) == (elementAdd group x (elementNegate group y))
  elementSubtract :: group -> Element group -> Element group -> Element group
  elementSubtract group x y = elementAdd group x (elementNegate group y)

  -- | Identity of the group.
  --
  -- Note [Added for completeness]
  --
  -- prop> \x -> (elementAdd group x groupIdentity) == x
  -- prop> \x -> (elementAdd group groupIdentity x) == x
  groupIdentity :: group -> Element group

  -- | Multiply an element of the group with respect to a scalar.
  --
  -- This is equivalent to adding the element to itself N times, where N is a scalar.
  scalarMultiply :: group -> Scalar group -> Element group -> Element group

  -- | Get the scalar that corresponds to an integer.
  --
  -- Note [Added for completeness]
  --
  -- prop> \x -> scalarToInteger group (integerToScalar group x) == x
  integerToScalar :: group -> Integer -> Scalar group

  -- | Get the integer that corresponds to a scalar.
  --
  -- Note [Added for completeness]
  --
  -- prop> \x -> integerToScalar group (scalarToInteger group x) == x
  scalarToInteger :: group -> Scalar group -> Integer

  -- | Encode an element of the group into bytes.
  --
  -- Note [Byte encoding in Group]
  --
  -- prop> \x -> decodeElement group (encodeElement group x) == CryptoPassed x
  encodeElement :: ByteArray bytes => group -> Element group -> bytes

  -- | Decode an element into the group from some bytes.
  --
  -- Note [Byte encoding in Group]
  decodeElement :: ByteArray bytes => group -> bytes -> CryptoFailable (Element group)

  -- | Encode a scalar into bytes.
  -- | Generate a new random element of the group, with corresponding scalar.
  generateElement :: MonadRandom randomly => group -> randomly (KeyPair group)

  -- | Size of elements, in bits
  elementSizeBits :: group -> Int

  -- | Size of scalars, in bits
  scalarSizeBits :: group -> Int

  -- | Deterministically create an arbitrary element from a seed bytestring.
  --
  -- __XXX__: jml would much rather this take a scalar, an element, or even an integer, rather than bytes
  -- because bytes mean that the group instances have to know about hash algorithms and HKDF.
  -- If the IntegerGroup class in SPAKE2 also oversized its input,
  -- then it and the ed25519 implementation would have identical decoding.
  arbitraryElement :: ByteArrayAccess bytes => group -> bytes -> Element group


-- | Map some arbitrary bytes into a scalar in a group.
decodeScalar :: (ByteArrayAccess bytes, Group group) => group -> bytes -> Scalar group
decodeScalar group bytes = integerToScalar group (bytesToNumber bytes)

-- | Size of elements in a group, in bits.
elementSizeBytes :: Group group => group -> Int
elementSizeBytes group = (elementSizeBits group + 7) `div` 8

-- | Size of scalars in a group, in bytes.
scalarSizeBytes :: Group group => group -> Int
scalarSizeBytes group = (scalarSizeBits group + 7) `div` 8

-- | A group key pair composed of the private part (a scalar)
-- and a public part (associated group element).
data KeyPair group
  = KeyPair
  { keyPairPublic :: !(Element group)
  , keyPairPrivate :: !(Scalar group)
  }

{-
Note [Byte encoding in Group]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

jml is unsure whether it is a good idea to put encode/decode methods in the 'Group' typeclass.

Reasons for:

 * cryptonite does it with 'EllipticCurve'
 * warner does it with spake2.groups

Reasons against:

 * mathematical structure of groups has no connection to serialization
 * might want multiple encodings for same mathematical group

Including for now on the assumption that I'm ignorant.

TODO: Revisit decision to put byte encoding in Group after we've done a couple of implementations
-}

{-
Note [Added for completeness]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Several methods were added to 'Group' out of a desire for mathematical completeness
rather than necessity for implementing SPAKE2.

These include:

 * 'groupIdentity' -- because groups have identities (just like semigroups)
 * 'scalarToInteger' and 'integerToScalar' -- because scalars are mathematically integers
 * 'encodeScalar' -- because having an inverse of 'decodeScalar' makes it easier to test

-}

-- TODO: Would be nice to put all the group definitions into other modules and
-- leave this as being a pure interface module

-- | Simple integer addition group.
--
-- Do __NOT__ use this for anything cryptographic.
newtype IntegerAddition = IntegerAddition { modulus :: Integer } deriving (Eq, Ord, Show)

instance Group IntegerAddition where
  type Element IntegerAddition = Integer
  type Scalar IntegerAddition = Integer

  elementAdd group x y = (x + y) `mod` modulus group
  elementNegate group x = negate x `mod` modulus group
  elementSubtract group x y = (x - y) `mod` modulus group
  groupIdentity _ = 0
  scalarMultiply group n x = (n * x) `mod` modulus group
  integerToScalar _ x = x
  scalarToInteger _ x = x
  encodeElement group x = unsafeNumberToBytes (elementSizeBytes group) (x `mod` modulus group)
  decodeElement _ bytes = CryptoPassed (bytesToNumber bytes)
  generateElement group = do
    scalarBytes <- getRandomBytes (scalarSizeBytes group)
    let scalar = decodeScalar group (scalarBytes :: ByteString)
    let element = scalarMultiply group scalar (groupIdentity group)
    pure (KeyPair element scalar)
  scalarSizeBits group = numBits (modulus group)  -- XXX: Incorrect value. Not sure what it should be.
  elementSizeBits group = numBits (modulus group) -- XXX: should be size of subgroup
  arbitraryElement group seed =
    let processedSeed = expandArbitraryElementSeed seed (elementSizeBytes group) :: ByteString
        r = (modulus group - 1) `div` modulus group -- XXX: should be size of subgroup
        h = bytesToNumber processedSeed `mod` modulus group
    in expSafe h r (modulus group)


-- | A finite group of integers with respect to multiplication modulo the group order.
--
-- Construct with 'makeIntegerGroup'.
data IntegerGroup
  = IntegerGroup
  { order :: !Integer
  , subgroupOrder :: !Integer
  , generator :: !Integer
  } deriving (Eq, Show)

-- | Construct an 'IntegerGroup'.
--
-- Will fail if generator is '1',
-- since having the identity for a generator means the subgroup is the entire group.
--
-- TODO: Find other things to check for validity.
makeIntegerGroup :: Integer -> Integer -> Integer -> Maybe IntegerGroup
makeIntegerGroup _ _ 1 = Nothing
makeIntegerGroup order subgroupOrder generator = Just (IntegerGroup order subgroupOrder generator)


instance Group IntegerGroup where
  type Element IntegerGroup = Integer
  type Scalar IntegerGroup = Integer

  elementAdd group x y = (x * y) `mod` order group
  -- At a guess, negation is scalar multiplication where the scalar is -1
  elementNegate group x = expSafe x (subgroupOrder group - 1) (order group)
  groupIdentity _ = 1
  scalarMultiply group n x = expSafe x (n `mod` subgroupOrder group) (order group)
  integerToScalar group x = x `mod` subgroupOrder group  -- XXX: Should we instead fail?
  scalarToInteger _ n = n
  encodeElement group = unsafeNumberToBytes (elementSizeBytes group)
  decodeElement group bytes =
    case bytesToNumber bytes of
      x
        | x <= 0 || x >= order group -> CryptoFailed CryptoError_PointSizeInvalid
        | expSafe x (subgroupOrder group) (order group) /= groupIdentity group -> CryptoFailed CryptoError_PointCoordinatesInvalid
        | otherwise -> CryptoPassed x
  generateElement group = do
    scalar <- generateMax (subgroupOrder group)
    let element = scalarMultiply group scalar (generator group)
    pure (KeyPair element scalar)
  scalarSizeBits group = numBits (subgroupOrder group)
  elementSizeBits group = numBits (order group)
  arbitraryElement group seed =
    let processedSeed = expandArbitraryElementSeed seed (elementSizeBytes group) :: ByteString
        p = order group
        q = subgroupOrder group
        r = (p - 1) `div` q
        h = bytesToNumber processedSeed `mod` p
    in expSafe h r p

i1024 :: IntegerGroup
i1024 =
  IntegerGroup
  { order = 0xE0A67598CD1B763BC98C8ABB333E5DDA0CD3AA0E5E1FB5BA8A7B4EABC10BA338FAE06DD4B90FDA70D7CF0CB0C638BE3341BEC0AF8A7330A3307DED2299A0EE606DF035177A239C34A912C202AA5F83B9C4A7CF0235B5316BFC6EFB9A248411258B30B839AF172440F32563056CB67A861158DDD90E6A894C72A5BBEF9E286C6B
  , subgroupOrder = 0xE950511EAB424B9A19A2AEB4E159B7844C589C4F
  , generator = 0xD29D5121B0423C2769AB21843E5A3240FF19CACC792264E3BB6BE4F78EDD1B15C4DFF7F1D905431F0AB16790E1F773B5CE01C804E509066A9919F5195F4ABC58189FD9FF987389CB5BEDF21B4DAB4F8B76A055FFE2770988FE2EC2DE11AD92219F0B351869AC24DA3D7BA87011A701CE8EE7BFE49486ED4527B7186CA4610A75
  }
